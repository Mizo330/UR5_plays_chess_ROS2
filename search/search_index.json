{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UR5 Chess ROS 2 \u2014 Documentation This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up. Project Environment To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container. Third-Party Packages Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable. Project Structure The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Overwiev"},{"location":"#ur5-chess-ros-2-documentation","text":"This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up.","title":"UR5 Chess ROS 2 \u2014 Documentation"},{"location":"#project-environment","text":"To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container.","title":"Project Environment"},{"location":"#third-party-packages","text":"Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable.","title":"Third-Party Packages"},{"location":"#project-structure","text":"The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Project Structure"},{"location":"gazebo_sim/","text":"Gazebo simulation This project sets up a custom Gazebo simulation environment containing a chess table, a chessboard base, the chessboard itself with all 32 chess pieces placed on the board. The simulation is integrated into a ROS 2 package and includes a Python script to automatically generate the .world file with the desired models and poses. At this point we would like to acknowledge Arun for his cintribution with the chess models which are available in his ROS1 chessrobo repository . About the world The Gazebo world file ( chess_room.world ) is generated dynamically using the generate_chess_sdf.py script. The script places all models (chessboard and pieces) based on a flexible parameter setup. Key Parameters The following parameters control how the models are positioned in the world: Parameter Description tile_size The size of one chess square (in meters). Determines spacing of the pieces. a1 World coordinates (x, y) where the A1 square of the board is placed. orientaion Sets the orientation of the board. These parameters can be located at the ur_chess_config.yaml file modification should be made here. Moreover, the height of elements are adjustable too (e.g. table or chess board height). Generating and launching the world The generation is quite simple. After modif\u00eding the parameters run the generation script. ros2 run chess_gazebo_world generate_chess.sdf.py After generating the world the simulation can be launched. Note that with this launch the chess game will not be active , only RVizz and Gazebo will be launched with the simulation of controlling the robot in the generated world. colcon build source install/setup.bash ros2 launch chess_gazebo_world chess_world_with_ur.launch.py Using the world If we would like to run the chess game itself with modified world generation, we DO NOT HAVE TO generate the world separately . This is because the ur_chess.launch.py file automatically calls the world generation process , so launching it will ensure that the world is built with the current configuration.","title":"Gazebo simulation"},{"location":"gazebo_sim/#gazebo-simulation","text":"This project sets up a custom Gazebo simulation environment containing a chess table, a chessboard base, the chessboard itself with all 32 chess pieces placed on the board. The simulation is integrated into a ROS 2 package and includes a Python script to automatically generate the .world file with the desired models and poses. At this point we would like to acknowledge Arun for his cintribution with the chess models which are available in his ROS1 chessrobo repository .","title":"Gazebo simulation"},{"location":"gazebo_sim/#about-the-world","text":"The Gazebo world file ( chess_room.world ) is generated dynamically using the generate_chess_sdf.py script. The script places all models (chessboard and pieces) based on a flexible parameter setup.","title":"About the world"},{"location":"gazebo_sim/#key-parameters","text":"The following parameters control how the models are positioned in the world: Parameter Description tile_size The size of one chess square (in meters). Determines spacing of the pieces. a1 World coordinates (x, y) where the A1 square of the board is placed. orientaion Sets the orientation of the board. These parameters can be located at the ur_chess_config.yaml file modification should be made here. Moreover, the height of elements are adjustable too (e.g. table or chess board height).","title":"Key Parameters"},{"location":"gazebo_sim/#generating-and-launching-the-world","text":"The generation is quite simple. After modif\u00eding the parameters run the generation script. ros2 run chess_gazebo_world generate_chess.sdf.py After generating the world the simulation can be launched. Note that with this launch the chess game will not be active , only RVizz and Gazebo will be launched with the simulation of controlling the robot in the generated world. colcon build source install/setup.bash ros2 launch chess_gazebo_world chess_world_with_ur.launch.py","title":"Generating and launching the world"},{"location":"gazebo_sim/#using-the-world","text":"If we would like to run the chess game itself with modified world generation, we DO NOT HAVE TO generate the world separately . This is because the ur_chess.launch.py file automatically calls the world generation process , so launching it will ensure that the world is built with the current configuration.","title":"Using the world"},{"location":"ros2_nodes/","text":"Nodes and Interfaces of UR_Chess Core Dependencies In addition to ROS 2, the project relies on several key packages: UR ROS 2 Driver (with gripper support): Provides real and simulated control of the UR5 arm and RH-P12-RN-A gripper. See Introduction for more. MoveIt & moveit_py : Used for motion planning and trajectory execution. python-chess : A Python library that manages the game logic, including move validation, board state updates, and FEN/PGN parsing. It\u2019s an essential component for managing chess rules. stockfish Python wrapper: Used to configure and interact with the Stockfish engine from Python. Nodes Game Manager The Game Manager is the central coordinator of the system. It enforces the rules, tracks game state, and mediates communication between nodes. It listens on the /game_control topic for a command to start a new game, which moves the UR5 to its initial position. Once initialized, it listens on /current_move for player or chess moves. Moves are validated using a python-chess Board instance. Invalid moves (e.g. wrong turn, illegal move, in-check) are rejected. Validated moves are forwarded to the MoveIt controller, and the system enters an \"in progress\" state, during which new moves are ignored. When a move finishes successfully, it is committed to the game board and the updated FEN is published on /chessboard_state . During each state change, the state of the move is published /move_status . This topic is mostly for debugging, and for the GUI feedback and flow controtl. Although Stockfish usually generates legal moves, this validation layer ensures robustness\u2014especially in user-controlled modes. Moveit controller The MoveIt Controller wraps the moveit_py API, enabling trajectory planning and execution with collision checking. It requires the UR simulation to be running and connected. Upon receiving a move request, the controller decodes it and handles special moves (e.g. castling or captures ) by splitting them into appropriate sub-actions. For example, in castling, the rook is moved before the king, even if the UCI command refers to the king only. The chessboard and all pieces are dynamically managed in the Planning Scene Monitor to reflect their current positions. For simplicity, each piece is represented as a cylinder for collision avoidance purposes. Although the controller was initially designed for full asynchronous operation\u2014planning all individual motions ahead of time and executing them in sequence\u2014this approach turned out to be impractical due to the complexity of real-time scene updates and hardware timing constraints. Instead, we implemented a semi-synchronous execution model : Each pick-and-place operation (i.e. a chess move) is broken into three distinct phases : Grasping the selected piece. Transporting the piece to the destination. Releasing the piece. Between each phase, we update the planning scene to reflect changes: When grasping, the piece is attached to the robot in the scene. When releasing, the piece is detached and added back to the board as a static object. This stepwise structure allowed us to: - Dynamically manage the scene for collision-aware planning. - Simplify coordination with the Game Manager. - Avoid planning errors due to outdated collision objects. While not fully parallel or pipelined, this approach strikes a balance between safety, control, and responsiveness\u2014critical for handling precise manipulations in a constrained space like a chessboard. Graphical Interface (GUI) The original ROS1 version lacked a full graphical interface, but for a system like this, having clear control and visual feedback is essential. We implemented the GUI using PyQt5 , a robust and well-supported toolkit for desktop applications. Through the GUI, users can start or stop the game as described in the Game Manager node. By changing game modes - AI vs AI , Player vs AI , or Player vs Player - in the launchfile, the GUI use changes from just feedback to a full playable game interface. Inputs are only accepted when it's the player's turn; otherwise, interaction is disabled to prevent invalid or conflicting actions. In Player vs AI or PvP mode, users can select and move pieces on the board. In the case of illegal move, the game managger will resend an error message what was wrong about it. The GUI also provides visual feedback, including pop-up messages for check and checkmate\u2014though these are disabled during the AI\u2019s turn to avoid clutter. Note: Due to ROS\u2019s distributed nature, it\u2019s technically possible to launch two GUIs on different devices within the same ROS network for PvP games. While this setup was tested and functional, full integration for a seamless experience remains a future goal. Stockfish Node This node runs the chess AI using the Python Stockfish package . At startup, the engine is dynamically downloaded via Docker, and its behavior can be fine-tuned using parameters such as Skill Level , Contempt , or Depth (e.g., to adjust how aggressively it plays or how deep it searches). The node subscribes to the /chessboard_state topic. Upon receiving a FEN string, it passes it to the engine and retrieves the best move. Thanks to the compact nature of FEN, the full board state\u2014including whose turn it is\u2014is preserved without needing additional context. When the game is in PvP mode , the node shuts down immediately on launch, as no AI is needed. In Player vs AI , it only computes and publishes moves when it's the AI\u2019s turn.","title":"ROS2 nodes"},{"location":"ros2_nodes/#nodes-and-interfaces-of-ur_chess","text":"","title":"Nodes and Interfaces of UR_Chess"},{"location":"ros2_nodes/#core-dependencies","text":"In addition to ROS 2, the project relies on several key packages: UR ROS 2 Driver (with gripper support): Provides real and simulated control of the UR5 arm and RH-P12-RN-A gripper. See Introduction for more. MoveIt & moveit_py : Used for motion planning and trajectory execution. python-chess : A Python library that manages the game logic, including move validation, board state updates, and FEN/PGN parsing. It\u2019s an essential component for managing chess rules. stockfish Python wrapper: Used to configure and interact with the Stockfish engine from Python.","title":"Core Dependencies"},{"location":"ros2_nodes/#nodes","text":"","title":"Nodes"},{"location":"ros2_nodes/#game-manager","text":"The Game Manager is the central coordinator of the system. It enforces the rules, tracks game state, and mediates communication between nodes. It listens on the /game_control topic for a command to start a new game, which moves the UR5 to its initial position. Once initialized, it listens on /current_move for player or chess moves. Moves are validated using a python-chess Board instance. Invalid moves (e.g. wrong turn, illegal move, in-check) are rejected. Validated moves are forwarded to the MoveIt controller, and the system enters an \"in progress\" state, during which new moves are ignored. When a move finishes successfully, it is committed to the game board and the updated FEN is published on /chessboard_state . During each state change, the state of the move is published /move_status . This topic is mostly for debugging, and for the GUI feedback and flow controtl. Although Stockfish usually generates legal moves, this validation layer ensures robustness\u2014especially in user-controlled modes.","title":"Game Manager"},{"location":"ros2_nodes/#moveit-controller","text":"The MoveIt Controller wraps the moveit_py API, enabling trajectory planning and execution with collision checking. It requires the UR simulation to be running and connected. Upon receiving a move request, the controller decodes it and handles special moves (e.g. castling or captures ) by splitting them into appropriate sub-actions. For example, in castling, the rook is moved before the king, even if the UCI command refers to the king only. The chessboard and all pieces are dynamically managed in the Planning Scene Monitor to reflect their current positions. For simplicity, each piece is represented as a cylinder for collision avoidance purposes. Although the controller was initially designed for full asynchronous operation\u2014planning all individual motions ahead of time and executing them in sequence\u2014this approach turned out to be impractical due to the complexity of real-time scene updates and hardware timing constraints. Instead, we implemented a semi-synchronous execution model : Each pick-and-place operation (i.e. a chess move) is broken into three distinct phases : Grasping the selected piece. Transporting the piece to the destination. Releasing the piece. Between each phase, we update the planning scene to reflect changes: When grasping, the piece is attached to the robot in the scene. When releasing, the piece is detached and added back to the board as a static object. This stepwise structure allowed us to: - Dynamically manage the scene for collision-aware planning. - Simplify coordination with the Game Manager. - Avoid planning errors due to outdated collision objects. While not fully parallel or pipelined, this approach strikes a balance between safety, control, and responsiveness\u2014critical for handling precise manipulations in a constrained space like a chessboard.","title":"Moveit controller"},{"location":"ros2_nodes/#graphical-interface-gui","text":"The original ROS1 version lacked a full graphical interface, but for a system like this, having clear control and visual feedback is essential. We implemented the GUI using PyQt5 , a robust and well-supported toolkit for desktop applications. Through the GUI, users can start or stop the game as described in the Game Manager node. By changing game modes - AI vs AI , Player vs AI , or Player vs Player - in the launchfile, the GUI use changes from just feedback to a full playable game interface. Inputs are only accepted when it's the player's turn; otherwise, interaction is disabled to prevent invalid or conflicting actions. In Player vs AI or PvP mode, users can select and move pieces on the board. In the case of illegal move, the game managger will resend an error message what was wrong about it. The GUI also provides visual feedback, including pop-up messages for check and checkmate\u2014though these are disabled during the AI\u2019s turn to avoid clutter. Note: Due to ROS\u2019s distributed nature, it\u2019s technically possible to launch two GUIs on different devices within the same ROS network for PvP games. While this setup was tested and functional, full integration for a seamless experience remains a future goal.","title":"Graphical Interface (GUI)"},{"location":"ros2_nodes/#stockfish-node","text":"This node runs the chess AI using the Python Stockfish package . At startup, the engine is dynamically downloaded via Docker, and its behavior can be fine-tuned using parameters such as Skill Level , Contempt , or Depth (e.g., to adjust how aggressively it plays or how deep it searches). The node subscribes to the /chessboard_state topic. Upon receiving a FEN string, it passes it to the engine and retrieves the best move. Thanks to the compact nature of FEN, the full board state\u2014including whose turn it is\u2014is preserved without needing additional context. When the game is in PvP mode , the node shuts down immediately on launch, as no AI is needed. In Player vs AI , it only computes and publishes moves when it's the AI\u2019s turn.","title":"Stockfish Node"}]}