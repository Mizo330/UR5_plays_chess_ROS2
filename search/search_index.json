{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UR5 Chess ROS 2 \u2014 Documentation This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up. Project Environment To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container. Third-Party Packages Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable. Project Structure The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Overwiev"},{"location":"#ur5-chess-ros-2-documentation","text":"This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up.","title":"UR5 Chess ROS 2 \u2014 Documentation"},{"location":"#project-environment","text":"To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container.","title":"Project Environment"},{"location":"#third-party-packages","text":"Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable.","title":"Third-Party Packages"},{"location":"#project-structure","text":"The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Project Structure"},{"location":"gazebo_sim/","text":"adssa","title":"Gazebo simulation"},{"location":"ros2_nodes/","text":"","title":"ROS2 nodes"},{"location":"stockfish/","text":"","title":"Stockfish"}]}