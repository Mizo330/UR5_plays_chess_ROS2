{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UR5 Chess ROS 2 \u2014 Documentation This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up. Project Environment To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container. Third-Party Packages Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable. Project Structure The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Overwiev"},{"location":"#ur5-chess-ros-2-documentation","text":"This documentation covers our university project, which involved converting the original ROS 1 version of UR5 Chess to ROS 2. During development, we quickly realized that a straightforward migration was not feasible. Due to significant architectural and API changes in ROS 2, much of the original codebase was incompatible. As a result, we opted to rebuild the system from the ground up.","title":"UR5 Chess ROS 2 \u2014 Documentation"},{"location":"#project-environment","text":"To ensure portability and minimize compatibility issues, we used Docker . This approach allowed us to avoid installing third-party packages and drivers directly into the repository. For convenience, we created scripts to handle building and running the container.","title":"Project Environment"},{"location":"#third-party-packages","text":"Before diving into our custom packages, we would like to acknowledge DanielBrenn for his contributions. His modifications to the UR driver made it possible to control the RH-P12-RN-A gripper in both Gazebo and MoveIt, and his general support throughout the project was invaluable.","title":"Third-Party Packages"},{"location":"#project-structure","text":"The system is orchestrated by the game manager node. It processes the current board state and robot status, handles incoming messages, and validates moves. Once a move is verified, the game manager delegates execution to the MoveIt controller. It also publishes feedback such as the game state in FEN format or the last move in UCI notation. Most decision-making and external interfaces are centralized here to ensure consistent message flow. The GUI node handles user interaction and provides feedback through an interactive, clickable chessboard. It supports AI vs AI , PvP , and Player vs AI modes with selectable sides. The GUI manages turn-based control, disabling input when it\u2019s not the player\u2019s turn. The Stockfish node receives FEN strings and responds with UCI moves. It adapts to the selected game mode\u2014for example, it disables itself in PvP mode and only plays when it\u2019s the AI\u2019s turn in other modes. The MoveIt controller wraps around moveit_py , which itself is a Python interface to the underlying MoveIt C++ libraries. This node translates UCI move commands into executable trajectories and sends them to the robot. It also handles special cases like castling and piece captures. For a deeper dive into each ROS 2 node and its internal workings, see the ros2_nodes section.","title":"Project Structure"},{"location":"gazebo_sim/","text":"Gazebo simulation This project sets up a custom Gazebo simulation environment containing a chess table, a chessboard base, the chessboard itself with all 32 chess pieces placed on the board. The simulation is integrated into a ROS 2 package and includes a Python script to automatically generate the .world file with the desired models and poses. At this point we would like to acknowledge Arun for his cintribution with the chess models which are available in his ROS1 chessrobo repository . About the world The Gazebo world file ( chess_room.world ) is generated dynamically using the generate_chess_sdf.py script. The script places all models (chessboard and pieces) based on a flexible parameter setup. Key Parameters The following parameters control how the models are positioned in the world: Parameter Description tile_size The size of one chess square (in meters). Determines spacing of the pieces. a1 World coordinates (x, y) where the A1 square of the board is placed. orientaion Sets the orientation of the board. These parameters can be located at the ur_chess_config.yaml file modification should be made here. Moreover, the height of elements are adjustable too (e.g. table or chess board height). Generating and launching the world The generation is quite simple. After modif\u00eding the parameters run the generation script. ros2 run chess_gazebo_world generate_chess.sdf.py After generating the world the simulation can be launched. Note that with this launch the chess game will not be active , only RVizz and Gazebo will be launched with the simulation of controlling the robot in the generated world. colcon build source install/setup.bash ros2 launch chess_gazebo_world chess_world_with_ur.launch.py","title":"Gazebo simulation"},{"location":"gazebo_sim/#gazebo-simulation","text":"This project sets up a custom Gazebo simulation environment containing a chess table, a chessboard base, the chessboard itself with all 32 chess pieces placed on the board. The simulation is integrated into a ROS 2 package and includes a Python script to automatically generate the .world file with the desired models and poses. At this point we would like to acknowledge Arun for his cintribution with the chess models which are available in his ROS1 chessrobo repository .","title":"Gazebo simulation"},{"location":"gazebo_sim/#about-the-world","text":"The Gazebo world file ( chess_room.world ) is generated dynamically using the generate_chess_sdf.py script. The script places all models (chessboard and pieces) based on a flexible parameter setup.","title":"About the world"},{"location":"gazebo_sim/#key-parameters","text":"The following parameters control how the models are positioned in the world: Parameter Description tile_size The size of one chess square (in meters). Determines spacing of the pieces. a1 World coordinates (x, y) where the A1 square of the board is placed. orientaion Sets the orientation of the board. These parameters can be located at the ur_chess_config.yaml file modification should be made here. Moreover, the height of elements are adjustable too (e.g. table or chess board height).","title":"Key Parameters"},{"location":"gazebo_sim/#generating-and-launching-the-world","text":"The generation is quite simple. After modif\u00eding the parameters run the generation script. ros2 run chess_gazebo_world generate_chess.sdf.py After generating the world the simulation can be launched. Note that with this launch the chess game will not be active , only RVizz and Gazebo will be launched with the simulation of controlling the robot in the generated world. colcon build source install/setup.bash ros2 launch chess_gazebo_world chess_world_with_ur.launch.py","title":"Generating and launching the world"},{"location":"ros2_nodes/","text":"","title":"ROS2 nodes"},{"location":"stockfish/","text":"","title":"Stockfish"}]}